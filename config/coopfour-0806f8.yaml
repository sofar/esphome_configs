esphome:
  # area:
  name: "coopfour-0806f8"
  friendly_name: "coopfour-0806f8"
#  project:
#    name: coop-uter
#    version: 4.0.0

esp32:
  framework:
    type: esp-idf
  board: esp32-s3-devkitc-1

packages:
  standard-basic-control: !include standard/basic.yaml
  standard-wifi: !include standard/wifi.yaml

  tracer-tracer: !include tracer/tracer.yaml
  tracer-load: !include tracer/load.yaml
  tracer-bat: !include tracer/bat.yaml
  tracer-pv: !include tracer/pv.yaml
  tracer-stats: !include tracer/stats.yaml
  tracer-settings: !include tracer/settings.yaml
  tracer-rtc: !include tracer/rtc.yaml

binary_sensor:

  - platform: gpio
    name: "Boot Button"
    pin:
      number: 0
      ignore_strapping_warning: true
      mode:
        input: true
      inverted: true
    disabled_by_default: true
    on_press:
      then:
        - button.press: device_restart

  - platform: gpio
    pin:
      number: GPIO47
      inverted: true
      mode:
        input: true
        pullup: true
    name: Door Opened
    filters:
      - delayed_on: 10ms
    # no action - purely informational

  - platform: gpio
    pin:
      number: GPIO48
      inverted: true
      mode:
        input: true
        pullup: true
    name: Door Closed
    filters:
      - delayed_on: 10ms
    # no action - purely informational

  - platform: gpio
    pin:
      number: GPIO15
      inverted: true
      mode:
        input: true
        pullup: true
    name: Open Button
    filters:
      - delayed_on: 10ms
    on_press:
      then:
        - switch.turn_on: relay1
    on_release:
      then:
        - switch.turn_off: relay1

  - platform: gpio
    pin:
      number: GPIO16
      inverted: true
      mode:
        input: true
        pullup: true
    name: Close Button
    filters:
      - delayed_on: 10ms
    on_press:
      then:
        - switch.turn_on: relay2
    on_release:
      then:
        - switch.turn_off: relay2

switch:
  # motor fwd (open door)
  - platform: gpio
    pin: GPIO1
    id: relay1
    name: Relay 1
    interlock: [relay2]
    on_turn_on:
      - rtttl.play: 'alert:d=8,o=5,b=100:d,e,d,e,d,e,d,e'
      - delay: 120s
      - rtttl.play: 'complete:d=8,o=6,b=100:e,d'
      - switch.turn_off: relay1

  # motor rev (close door)
  - platform: gpio
    pin: GPIO2
    id: relay2
    name: Relay 2
    interlock: [relay1]
    on_turn_on:
      - rtttl.play: 'alert:d=8,o=5,b=100:d,e,d,e,d,e,d,e'
      - delay: 120s
      - rtttl.play: 'complete:d=8,o=6,b=100:e,d'
      - switch.turn_off: relay2

  # lamp
  - platform: gpio
    pin: GPIO41
    id: relay3
    name: Relay 3

#  # unused
#  - platform: gpio
#    pin: GPIO42
#    id: relay4
#    name: Relay 4
#  - platform: gpio
#    pin:
#      number: GPIO45
#      ignore_strapping_warning: true
#    id: relay5
#    name: Relay 5
#  - platform: gpio
#    pin:
#      number: GPIO46
#      ignore_strapping_warning: true
#    id: relay6
#    name: Relay 6

uart:
  id: uart_bus
  tx_pin: GPIO17
  rx_pin: GPIO18
  baud_rate: 115200
  data_bits: 8
  stop_bits: 1
  parity: NONE

  # uncomment this to debug the serial data tx >>> and rx <<< streams:
  debug:
    direction: BOTH
    after:
      timeout: 100ms
    sequence:
      - lambda: UARTDebug::log_hex(direction, bytes, ' ');

modbus:
  send_wait_time: 100ms
  id: modbus_epever

modbus_controller:
  - id: epever
    address: 0x01
    modbus_id: modbus_epever
    allow_duplicate_commands: false
    command_throttle: 200ms
    setup_priority: -10
    update_interval: 300s

# buzzer
output:
  - platform: ledc
    pin: GPIO21
    id: buzzer

rtttl:
  output: buzzer
  id: rtttl_buzzer
  gain: 30%

light:
  - platform: esp32_rmt_led_strip
    id: rgb_led
    name: "RGB LED"
    rgb_order: RGB
    pin: GPIO38
    num_leds: 1
    chipset: WS2812

globals:
  - id: pv_history
    type: float[8]
    initial_value: '{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}'

text_sensor:
  # The tracer/pv.yaml file has a lambda in the panel_voltage sensor
  # that publishes to this template sensor, and keeps the above pv_history
  # array updated with values. This template text_sensor then translates
  # changes in it to open/close events.
  # because the initial state will be unknown, after a fresh boot this will
  # automatically run the open or close sequence a few minutes after being
  # powered on.
  - platform: template
    name: "Day/Night"
    id: day_night_mode
    on_value:
      - if:
          condition:
            lambda: 'return id(day_night_mode).state == "day";'
          then:
            - rtttl.play: 'alert:d=8,o=5,b=100:d,e,d,e,d,e,d,e'
            - switch.turn_on: relay1
            - delay: 120s
            - rtttl.play: 'complete:d=8,o=6,b=100:e,d'
            - switch.turn_off: relay1
      - if:
          condition:
            lambda: 'return id(day_night_mode).state == "night";'
          then:
            - rtttl.play: 'alert:d=8,o=5,b=100:e,d,e,d,e,d,e,d'
            - switch.turn_on: relay3
            - delay: 600s
            - switch.turn_on: relay2
            - delay: 120s
            - rtttl.play: 'complete:d=8,o=6,b=100:e,d'
            - switch.turn_off: relay2
