esphome:
  # area:
  name: "coopfour-0806f8"
  friendly_name: "coopfour-0806f8"
#  project:
#    name: coop-uter
#    version: 4.0.0

esp32:
  framework:
    type: esp-idf
  board: esp32-s3-devkitc-1

packages:
  standard-basic-control: !include standard/basic.yaml
  standard-wifi: !include standard/wifi.yaml

  # basic equipment status
  tracer-tracer: !include tracer/tracer.yaml
  # load data
  tracer-load: !include tracer/load.yaml
  # battery data
  tracer-bat: !include tracer/bat.yaml
  # panel data
  tracer-pv: !include tracer/pv.yaml
  # statistics
  tracer-stats: !include tracer/stats.yaml
  # battery configurations
  tracer-settings-bat: !include tracer/settings-bat.yaml
  # load toggle on/off
  tracer-settings-load: !include tracer/settings-load.yaml
  # reads the RTC.
  tracer-rtc: !include tracer/rtc.yaml

binary_sensor:
  - platform: gpio
    name: "Boot Button"
    pin:
      number: 0
      ignore_strapping_warning: true
      mode:
        input: true
      inverted: true
    disabled_by_default: true
    on_press:
      then:
        - button.press: device_restart

  - platform: gpio
    pin:
      number: GPIO47
      inverted: true
      mode:
        input: true
        pullup: true
    name: Door Opened
    filters:
      - delayed_on: 10ms
    # no action - purely informational

  - platform: gpio
    pin:
      number: GPIO48
      inverted: true
      mode:
        input: true
        pullup: true
    name: Door Closed
    filters:
      - delayed_on: 10ms
    # no action - purely informational

  - platform: gpio
    pin:
      number: GPIO15
      inverted: true
      mode:
        input: true
        pullup: true
    name: Open Button
    filters:
      - delayed_on: 10ms
    on_press:
      then:
        - switch.turn_on: relay1
    on_release:
      then:
        - switch.turn_off: relay1

  - platform: gpio
    pin:
      number: GPIO16
      inverted: true
      mode:
        input: true
        pullup: true
    name: Close Button
    filters:
      - delayed_on: 10ms
    on_press:
      then:
        - switch.turn_on: relay2
    on_release:
      then:
        - switch.turn_off: relay2

switch:
  # motor fwd (open door)
  - platform: gpio
    pin: GPIO1
    id: relay1
    name: Relay 1
    interlock: [relay2]
    on_turn_on:
      - rtttl.play: 'alert:d=8,o=5,b=100:d,e,d,e,d,e,d,e'
      - delay: 120s
      - rtttl.play: 'complete:d=8,o=6,b=100:e,d'
      - switch.turn_off: relay1

  # motor rev (close door)
  - platform: gpio
    pin: GPIO2
    id: relay2
    name: Relay 2
    interlock: [relay1]
    on_turn_on:
      - rtttl.play: 'alert:d=8,o=5,b=100:d,e,d,e,d,e,d,e'
      - delay: 120s
      - rtttl.play: 'complete:d=8,o=6,b=100:e,d'
      - switch.turn_off: relay2

  # lamp
  - platform: gpio
    pin: GPIO41
    id: relay3
    name: Relay 3

#  # unused
#  - platform: gpio
#    pin: GPIO42
#    id: relay4
#    name: Relay 4
#  - platform: gpio
#    pin:
#      number: GPIO45
#      ignore_strapping_warning: true
#    id: relay5
#    name: Relay 5
#  - platform: gpio
#    pin:
#      number: GPIO46
#      ignore_strapping_warning: true
#    id: relay6
#    name: Relay 6

uart:
  id: uart_bus
  tx_pin: GPIO17
  rx_pin: GPIO18
  baud_rate: 115200
  data_bits: 8
  stop_bits: 1
  parity: NONE

  # uncomment this to debug the serial data tx >>> and rx <<< streams:
  debug:
    direction: BOTH
    after:
      timeout: 100ms
    sequence:
      - lambda: UARTDebug::log_hex(direction, bytes, ' ');

modbus:
  send_wait_time: 100ms
  id: modbus_epever

modbus_controller:
  - id: epever
    address: 0x01
    modbus_id: modbus_epever
    allow_duplicate_commands: false
    command_throttle: 200ms
    setup_priority: -10
    update_interval: 300s

# buzzer
output:
  - platform: ledc
    pin: GPIO21
    id: buzzer

rtttl:
  output: buzzer
  id: rtttl_buzzer
  gain: 30%

light:
  - platform: esp32_rmt_led_strip
    id: rgb_led
    name: "RGB LED"
    rgb_order: RGB
    pin: GPIO38
    num_leds: 1
    chipset: WS2812

text:
  - platform: template
    name: "Configuration payload"
    mode: text
    entity_category: config
    update_interval: 3600s
    id: configuration_payload
    set_action:
      lambda: |-
        JsonDocument root;
        esphome::modbus_controller::ModbusController *controller = id(epever);

        if (deserializeJson(root, x) != DeserializationError::Ok) {
          ESP_LOGI("devconf", "bad JSON data payload");
          return;
        }

        //FIXME - this is kinda bad. We should instead just be able to consume
        //        an entire battery setup payload all at once.

        if (root["battery_type"]) {
          int v = root["battery_type"];
          esphome::modbus_controller::ModbusCommandItem write_command =
              esphome::modbus_controller::ModbusCommandItem::create_write_single_command(
                      controller, 0x9000, v);
          epever->queue_command(write_command);
          ESP_LOGI("devconf", "wrote battery_type %d", v);
        }

        return;
    lambda: |-
      JsonDocument root;
      std::string x;

      root["battery_type"] = id(battery_type).state;

      serializeJson(root, x);
      return x;

  - platform: template
    name: "Set RTC"
    mode: text
    entity_category: config
    update_interval: 3600s
    id: configuration_rtc
    set_action:
      lambda: |-
        // input `x` = "1970-01-01 12:34:56"
        int year, month, day, hour, minute, second;

        year = std::stoi(x.substr(0, 4)) % 100;
        month = std::stoi(x.substr(5, 2));
        day = std::stoi(x.substr(8, 2));
        hour = std::stoi(x.substr(11, 2));
        minute = std::stoi(x.substr(14, 2));
        second = std::stoi(x.substr(17, 2));

        std::vector<uint16_t> rtc_data = {uint16_t((minute << 8) | second), uint16_t((day << 8) | hour),
                                                uint16_t((year << 8) | month)};
        esphome::modbus_controller::ModbusCommandItem set_rtc_command = esphome::modbus_controller::ModbusCommandItem::create_write_multiple_command(epever, 0x9013, 3, rtc_data);
        epever->queue_command(set_rtc_command);
        ESP_LOGI("rtcconf", "RTC set to %04d-%02d-%02d %02d:%02d:%02d", year + 2000, month, day, hour, minute, second);
    lambda: |-
      return id(template_rtc).state;

# time based automation
time:
  # I really don't like to have to use this, I'd much rather use the modbus RTC
  # at boot time, and then possibly later sync the RTC to hass/sntp
  - platform: sntp
    id: sntp_time
    timezone: America/Los_Angeles
    servers:
      - 0.pool.ntp.org
      - 1.pool.ntp.org
      - 2.pool.ntp.org

sun:
  latitude: 45.649828°
  longitude: -123.218886°

  on_sunrise:
    - elevation: 0°
      then:
        - logger.log: 'Opening door'
        - switch.turn_on: relay1

  on_sunset:
    - elevation: 1°
      # about 12 minutes before sunset
      then:
        - logger.log: 'Turning on light'
        - switch.turn_on: relay3
    - elevation: -3°
      # about 20 minutes after sunset
      then:
        - logger.log: 'Closing door'
        - switch.turn_on: relay2
    - elevation: -4°
      # about 25 minutes after closing door
      then:
        - logger.log: 'Turning off light'
        - switch.turn_off: relay3

