sensor:
  - platform: modbus_controller
    modbus_controller_id: epever
    id: device_day_night
    name: "Device night mode"
    address: 0x200c
    # The ESPHOME modbus `discrete_input` is expecting 2
    # bytes of data, but modbus spec clearly indicates
    # if we read 1 readonly coil we should get 1 byte back.
    custom_command: [0x01, 0x02, 0x20, 0x0C, 0x00, 0x01]
    lambda: |-
      return data[0];

  - platform: modbus_controller
    modbus_controller_id: epever
    id: device_temperature
    name: "Device temperature"
    address: 0x3111
    unit_of_measurement: °C
    register_type: read
    value_type: S_WORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.01

  - platform: modbus_controller
    modbus_controller_id: epever
    id: power_components_temperature
    name: "Power components temperature"
    address: 0x3112
    unit_of_measurement: °C
    register_type: read
    value_type: S_WORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.01

  - platform: modbus_controller
    modbus_controller_id: epever
    id: battery_soc
    name: "Battery SOC"
    address: 0x311A
    unit_of_measurement: "%"
    register_type: read
    value_type: U_WORD
    accuracy_decimals: 0

  - platform: modbus_controller
    modbus_controller_id: epever
    id: remote_battery_temperature
    name: "Remote battery temperature"
    address: 0x311B
    unit_of_measurement: °C
    register_type: read
    value_type: S_WORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.01

text_sensor:
  - platform: modbus_controller
    modbus_controller_id: epever
    id: battery_status
    name: "Battery status"
    address: 0x3200
    register_type: read
    raw_encode: HEXBYTES
    response_size: 2
    lambda: |-
      uint16_t v = modbus_controller::word_from_hex_str(x, 0);
      std::string s;

      if (v & 0xf == 0)
        s += "Normal, ";
      if (v & 0xf == 1)
        s += "Over voltage, ";
      if (v & 0xf == 2)
        s += "Under voltage, ";
      if (v & 0xf == 3)
        s += "Over discharge, ";
      if (v & 0xf == 4)
        s += "Fault, ";
      if (v & 0xf0 == 0x10)
        s += "Over temperature, ";
      if (v & 0xf0 == 0x20)
        s += "Under temperature, ";
      if (v & 0x0100)
        s += "Battery resistance abnormal, ";
      if (v & 0x8000)
        s += "Battery rated voltage incorrect, ";

      // trim trailing ", "
      if (s.length() > 0)
        s = s.substr(0, s.length() - 2);

      return s;

  - platform: modbus_controller
    modbus_controller_id: epever
    id: charger_status
    name: "Charger status"
    address: 0x3201
    register_type: read
    raw_encode: HEXBYTES
    response_size: 2
    lambda: |-
      uint16_t v = modbus_controller::word_from_hex_str(x, 0);
      std::string s;

      if (v & 0x1 == 0)
        s += "Standby, ";
      if (v & 0x1 == 1)
        s += "Running, ";
      if (v & 0x2)
        s += "Fault, ";
      if (v & 0xc == 0)
        s += "Not charging, ";
      if (v & 0xc == 8)
        s += "Float charging, ";
      if (v & 0xc == 0xa)
        s += "Boost charging, ";
      if (v & 0xc == 0xc)
        s += "Equalizing, ";
      if (v & 0x10)
        s += "PV input is short circuit, ";
      if (v & 0x40)
        s += "Disequilibrium in three circuits, ";
      if (v & 0x80)
        s += "Load MOSFET is short circuit, ";
      if (v & 0x100)
        s += "Load is short circuit, ";
      if (v & 0x200)
        s += "Load is over current, ";
      if (v & 0x400)
        s += "Input is over current, ";
      if (v & 0x800)
        s += "Anti-reverse MOSFET is short circuit, ";
      if (v & 0x1000)
        s += "Charging or Anti-reverse MOSFET is open circuit, ";
      if (v & 0x2000)
        s += "Charging MOSFET is short circuit, ";
      if (v & 0xc000 == 0x4000)
        s += "No input power connected, ";
      if (v & 0xc000 == 0x8000)
        s += "Higher input voltage, ";
      if (v & 0xc000 == 0xc000)
        s += "Input voltage error, ";

      // trim trailing ", "
      if (s.length() > 0)
        s = s.substr(0, s.length() - 2);

      return s;

  - platform: modbus_controller
    modbus_controller_id: epever
    id: discharging_status
    name: "Discharging status"
    address: 0x3202
    register_type: read
    raw_encode: HEXBYTES
    response_size: 2
    lambda: |-
      uint16_t v = modbus_controller::word_from_hex_str(x, 0);
      std::string s;

      if (v & 0x1 == 0)
        s += "Standby, ";
      if (v & 0x1 == 1)
        s += "Running, ";
      if (v & 0x2)
        s += "Fault, ";
      if (v & 0x10)
        s += "Output over voltage, ";
      if (v & 0x20)
        s += "Boost over voltage, ";
      if (v & 0x40)
        s += "Short circuit in high voltage side, ";
      if (v & 0x80)
        s += "Input over voltage, ";
      if (v & 0x100)
        s += "Output voltage abnormal, ";
      if (v & 0x200)
        s += "Unable to stop discharging, ";
      if (v & 0x400)
        s += "Unable to discharge, ";
      if (v & 0x800)
        s += "Short circuit, ";
      if (v & 0x3000 == 0)
        s += "Light load, ";
      if (v & 0x3000 == 0x1000)
        s += "Moderate load, ";
      if (v & 0x3000 == 0x2000)
        s += "Rated load, ";
      if (v & 0x3000 == 0x3000)
        s += "Overload, ";
      if (v & 0xc000 == 0)
        s += "Input voltage normal, ";
      if (v & 0xc000 == 0x4000)
        s += "Input voltage low, ";
      if (v & 0xc000 == 0x8000)
        s += "Input voltage high, ";
      if (v & 0xc000 == 0xc000)
        s += "No access, ";

      // trim trailing ", "
      if (s.length() > 0)
        s = s.substr(0, s.length() - 2);

      return s;
